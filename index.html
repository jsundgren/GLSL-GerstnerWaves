<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>TNM084 - Wave simulation using Gerstner waves</title>
        <!-- Custom CSS -->
        <link href="css/style.css" rel="stylesheet">
        
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="x-shader/x-vertex" id="vertexShader">

            uniform float time;
            //uniform float steepness;
            //uniform float wave_length;
            float PI = 3.1456;
            float g = 9.82;
            varying vec3 vNormal;
            varying vec3 vPosition;
            // wave(dir, steepness, wavelength)
            vec4 wave_a = vec4(1.0, 0, 0.5, 10);
            vec4 wave_b = vec4(0, 1.0, 0.25, 20);
            vec4 wave_c = vec4(1.0, 1.0, 0.15, 10);
            
            vec3 GerstnerWaves(vec4 wave, vec3 pos){
                
                float steepness = wave.z;
                float wave_length = wave.w;
                float k = 2.0 * PI / wave_length;
                float c = sqrt(g / k);
                vec2 d = normalize(wave.xy);
			    float f = k * (dot(d, pos.xz) - c * time);
                float a = steepness / k;
                
                return vec3(d.x * (a * cos(f)),	a * sin(f),	d.y * (a * cos(f)));
            }
            
            vec3 CalcTangent(vec4 wave, vec3 pos, vec3 tangent){
                
                float steepness = wave.z;
                float wave_length = wave.w;
                float k = 2.0 * PI / wave_length;
                float c = sqrt(g / k);
                vec2 d = normalize(wave.xy);
			    float f = k * (dot(d, pos.xz) - c * time);
                
			    tangent += vec3(-d.x * d.y * (steepness * sin(f)),
                                d.y * (steepness * cos(f)),
				                -d.y * d.y * (steepness * sin(f)));
                
                return tangent;
            }
            
            vec3 CalcBinormal(vec4 wave, vec3 pos, vec3 binormal){
                
                float steepness = wave.z;
                float wave_length = wave.w;
                float k = 2.0 * PI / wave_length;
                float c = sqrt(g / k);
                vec2 d = normalize(wave.xy);
			    float f = k * (dot(d, pos.xz) - c * time);
                
                binormal += vec3(-d.x * d.x * (steepness * sin(f)),
				                d.x * (steepness * cos(f)),
                                -d.x * d.y * (steepness * sin(f)));
                
                return binormal;
            }
            
                  
            void main() {
              
	          vPosition = position;
              vec3 new_position = position;
              vec3 tangent = vec3(1.0, 0, 0);
              vec3 binormal = vec3(0, 0, 1.0);
              vec3 wave_pos = new_position;
              wave_pos += GerstnerWaves(wave_a, new_position);
              tangent = CalcTangent(wave_a, new_position, tangent);
              binormal = CalcBinormal(wave_a, new_position, binormal);
              
              wave_pos += GerstnerWaves(wave_b, new_position);
              tangent = CalcTangent(wave_b, new_position, tangent);
              binormal = CalcBinormal(wave_b, new_position, binormal);
              
              wave_pos += GerstnerWaves(wave_c, new_position);
              tangent = CalcTangent(wave_c, new_position, tangent);
              binormal = CalcBinormal(wave_c, new_position, binormal);
              
              vNormal = normalize(cross(binormal, tangent));
              
              gl_Position = projectionMatrix * modelViewMatrix * vec4( wave_pos, 1.0 );
              
            }
        </script>
        <script type="x-shader/x-vertex" id="fragmentShader">
            
            uniform vec3 camera;
            uniform vec3 light;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            float dnc( vec3 a, vec3 b ) {
              return clamp( dot(a, b), 0.0, 1.0 );
            }
            
            void main() {
            
              vec3 L = normalize( light - vPosition );
              vec3 V = normalize( camera - vPosition );
              vec3 H = normalize( L + V );
              vec3 R = normalize( reflect( -light, vNormal ));

              float ambient = 0.01;
              float diffuse = dnc( L, vNormal );
              float specular = pow( dnc( vNormal, H ), 4.0);

              vec3 material = vec3( 0.0, 0.0, 1.0 );
              vec3 newColor = material * ( specular + diffuse + ambient );
              
              gl_FragColor = vec4( newColor, 1.0 );
            }
        </script>

	</head>
	<body>
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
		<script src="js/scene.js"></script>
        <script src="js/geometrySetup.js"></script>
        <script src="js/render.js"></script>        
	</body>
</html>