<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>TNM084 - Wave simulation using Gerstner waves</title>
        <!-- Custom CSS -->
        <link href="css/style.css" rel="stylesheet">
        
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="x-shader/x-vertex" id="vertexShader">

            uniform float time;
            uniform float A;
            uniform float W;
            uniform float dir;
            uniform float S;
            uniform float L;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vGrad;
            
            // Wave 1
            float A1 = 1.0;
            float W1 = 1.0;
            vec3 dir1 = vec3 ( 1.0, 0.0, 0.0 );
            float S1 = 2.0;
            float L1 = 10.0;
            // Wave 2
            float A2 = A * 0.2;
            float W2 = W * 10.0;
            vec3 dir2 = vec3 ( dir*0.7, 0.3, 0.0 );
            float S2 = S * 0.2;
            float L2 = L * 0.5;
            // Wave 3
            float A3 = A * 1.0;
            float W3 = W * 1.0;
            vec3 dir3 = vec3 ( dir*0.1, 0.4, 0.0 );
            float S3 = S * 1.0;
            float L3 = L * 1.0;
            // Wave 4
            float A4 = A * 0.1;
            float W4 = W * 5.0;
            vec3 dir4 = dir * vec3 ( dir*0.3, 0.4, 0.0 );
            float S4 = S * 2.0;
            float L4 = L * 10.0;
            
            
            
            
            vec3 waves(float amp, float wave_number, vec3 direction, float speed, float wave_length){
                // Crest
                //float Q = 1.0 / (wave_number*amp*2.0);
                float phaseConstant = speed * (2.0/wave_length);
                    
                float x_pos = position.x;
                float z_pos = position.z;
                float up = 0.0;
                //xPos = position.x + (( Q * amp ) * direction.x * cos(wave_number * dot(direction, position) + phaseConstant*time));
                //yPos = position.y + (( Q * amp ) * direction.y * cos(wave_number * dot(direction, position) + phaseConstant*time));
                //up = amp*sin(wave_number * dot(direction, position) + phaseConstant*time);
                
                float k = (2.0 * 3.14) / wave_length;
                float f = k * (x_pos - speed * time);
                x_pos += (amp + cos(f));
                z_pos = amp * sin(f);
                return vec3(x_pos, 0.0, z_pos);
            }
            
            
                        
            void main() {
            
              vec3 grad;
              grad *= A;
              
              vNormal = normal;
	          vPosition = position;
              vGrad = grad;
              
              vec3 newPosition = position + (normal * (waves(A1, W1, dir1, S1, L1)));
              gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
              
            }
        </script>
        <script type="x-shader/x-vertex" id="fragmentShader">
            
            uniform vec3 camera;
            uniform vec3 light;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vGrad;
            
            float dnc( vec3 a, vec3 b ) {
              return clamp( dot(a, b), 0.0, 1.0 );
            }
            
            void main() {
            
            // Calculate new normal (Stegus)
              vec3 g = vGrad;
              vec3 N_o = vNormal;
              vec3 g_p = ( g * N_o ) * N_o;
              vec3 g_o = g - g_p;
              vec3 N_ = N_o - g_o;
              vec3 N = normalize( N_ );
              
              vec3 L = normalize( light - vPosition );
              vec3 V = normalize( camera - vPosition );
              vec3 H = normalize( L + V );
              vec3 R = normalize( reflect( -light, N ));

              float ambient = 0.01;
              float diffuse = dnc( L, vNormal );
              float specular = pow( dnc( vNormal, H ), 4.0);

              vec3 material = vec3( 0.0, 0.0, 1.0 );
              vec3 newColor = material * ( specular + diffuse + ambient );
              
              gl_FragColor = vec4( newColor, 1.0 );
            }
        </script>

	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/scene.js"></script>
        <script src="js/geometrySetup.js"></script>
        <script src="js/render.js"></script>        
	</body>
</html>